%!TEX root = ../../main.tex

\chapter{Introduction}
These days one of the key benchmarks for technology is processing speed and
calculation power. To realize mathematical operations and execute programs,
different platforms can be utilized. The most commonly used unit is the standard
processor consisting of transistors realized on silicium and other materials.
Another crucial technology that is gaining more attention is the so-called
\acf{FPGA}. The FPGA consists of logical units that can
be wired and configured individually for the required use-case. The advantage of
FPGA is that the speed of applications can be drastically increased since the
hardware will be very optimized for the specific application.
This project aims to develop a \acf{IP}-core based on the Open
Source Instruction Set \acs{RISC}-V. The goal is to build a reusable unit of logic that can
interpret compiled C-Code. The IP core is realized in the \ac{VHDL} language and will be deployed on a FPGA. IP Cores are used in every computer, phone and electronic device that requires to execute some computational function. The developers of these IP Cores are big
companies like Intel, ARM or AMD. These IP Cores and Instruction Sets are strictly
licensed and not available for everyone. For the development of an own IP Core the
Instruction Set is the main source of information and therefore the RISC-V
open-source Instruction Set is used for this project.
\section{Motivation}
RISC-V was first proposed at Berkeley University in 2010. The architecture is
therefore relatively new in comparison to others like x86, ARM or SPARC. Even
though its young age is already very promising, every year new breakthroughs are
achieved in the field of RISC-V based cores.
MicroMagic for example announced in 2020 a chip with a total CoreMark score of
13000 and an incredible 110000 Coremark/Watt. This poses a significant
development and is approximately 10 times better than any CISC, RISC or MIPS
implementation in terms of Performance per Watt.
Many other companies like Alibaba, Nvidia and SiFive are currently increasing
research on RISC-V based cores.
The Motivation behind this project was to gain experience in processor and \ac{FPGA}
design and verification. Furthermore it poses an interesting opportunity for students
to work on a new and upcoming processor architecture.

\section{Project Planning}
In order to control the flow of the project, the V-Model approach was taken. The
project is therefore divided into Requirements, System Design, Architecture Design,
Module Design and Implementation. After Implementation the corresponding
verification phases are ready to be executed, starting from the lowest level (Unit
Verification) to Integration Verification, System Verification and last but not least
Acceptance Verification.


\begin{figure}[h]
	\centering
	\includegraphics[scale=0.65]{vmod.png}
	\caption{V-Model}
\end{figure}

At the beginning of every project phase, workloads were defined e.g. the definition of
the Control Unit Entity. The target of Requirements Engineering was to define
everything that is expected from the core and gather information about RISC-V. The
data path as well as the entities of the Control Unit, Arithmetic Unit, Register Files,
Exception Control, \acs{PMP} \& \acs{PMA} Checker and AXI4-Lite Interfaces as well as a short
summary of their function were defined during System Design. The next step,
Architecture Design, aimed to further specify the entities mentioned above and
sub-divide them into several entities. Module Design will be executed to define every
single architecture, after that implementation and testing may start.

\section{History}
The history of computing is a very complex topic, it goes back to ancient times where mathematicians used simple mechanical devices such as the abacus. An abacus is usually comprised of a frame and multiple rods with pearls mounted on them. Unlike modern computation devices, it does not calculate on its own but is used to provide an overview of the calculations (e.g. the sum and carry)\cite{ORegan:2021}. The following section will give a short overview of the history of computational devices.\\
The Zuse Z1, often referred to as the first computer, was invented and build by Conrad Zuse in 1938.
Despite the fact that it was a mechanical computer, the Zuse Z1 was able to perform several arithmetic operations including floating point arithmetic. Later developments of the Z1 are the Z2 and Z3. The Z3 relied on relays and was therefore not fully digital. As the first programmable computer the Z3 marks a milestone in the history of computational devices\cite{ORegan:2021}.\\
Developed by the University of Pennsylvania in cooperation with the Ballistics Research Laboratory of the US Army, \ac{ENIAC} can be seen as one of the first large scale computers (completed in 1946). It was fully digital, using vacuum tubes. Complex computations such as thirty five 10-digit divisions can be carried out in one second using \ac{ENIAC}. Reprogramming the machine needed a great deal of effort, since it did not employ the stored-program concept. Its successor the 
\ac{EDVAC} added this functionality to the design \cite{ORegan:2021}. 
A major milestone is marked by the invention of the transistor in 1947 (Bardeen and Brattan, point-contact transistor) and the junction-based transistor in 1951 by Shockley \cite{ORegan:2021}. These inventions allowed computers to decrease drastically in size, power and meantime to failure.\\
With the Intel 4004 the first ever microprocessor was invented in 1971. It was able to run at a speed of 60000 operations per second, providing roughly the same computational power as the \ac{ENIAC} in 1946\cite{ORegan:2021}. Its successors (the 8008 and 8086) are the base of Intel's current x86 architecture.
As one of the first personal computers, the Apple I and its successor the Apple II played a big role in providing more people with access to computational devices. The Apple I was released in 1976, it had to be assembled by the customer\cite{ORegan:2021}. 
From this point on computing power increased drastically, this is achieved by higher clock frequencies, pipelining, parallel processing etc.. Most computer architectures like the x86 instruction set are \ac{CISC} based. One of the first architectures to take a different approach towards simpler but faster instructions is the \ac{MIPS} \ac{ISA}, more information on this architecture can be found in \cite{patterson:2020}.\\
One of the latest developments of \ac{RISC} based computers is the developement of the RISC-V \ac{ISA} in 2010.
